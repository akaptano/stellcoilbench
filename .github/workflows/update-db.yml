# .github/workflows/update-db.yml
name: Update StellCoilBench Database

on:
  push:
    branches: [ main ]

jobs:
  update-db:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Check out repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history for proper branch operations
          token: ${{ secrets.GITHUB_TOKEN }}  # Explicit token for write access

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"
          cache: 'pip'

      - name: Install package
        run: |
          pip install -e .

      - name: Run benchmark cases
        run: |
          # Run case files that are NEW or have FAILED (no successful submission generated)
          # A case file should run if:
          #   1. It's new (didn't exist in previous commit), OR
          #   2. It exists but has no successful submission (will retry until successful)
          # Directory will be: submissions/<surface>/<GITHUB_ACTOR>/<MM-DD-YYYY_HH-MM>/
          echo "GITHUB_ACTOR: $GITHUB_ACTOR"
          echo "Finding cases to run (new or failed)..."
          
          # Get the previous commit (if it exists)
          # Check if we have at least one commit before HEAD
          if git rev-parse --verify HEAD~1 > /dev/null 2>&1; then
            PREVIOUS_COMMIT="HEAD~1"
            echo "Previous commit found: $(git rev-parse --short HEAD~1)"
          else
            # First commit - all files are new
            PREVIOUS_COMMIT=""
            echo "This appears to be the first commit - all case files will be considered new"
          fi
          
          # Find all .yaml files in cases/ (excluding README.md)
          ALL_CASE_FILES=$(find cases -name "*.yaml" -type f | sort)
          
          if [ -z "$ALL_CASE_FILES" ]; then
            echo "ERROR: No .yaml files found in cases/ directory!"
            exit 1
          fi
          
          echo "All case files found:"
          echo "$ALL_CASE_FILES"
          
          # Use Python to check which case files have successful submissions
          # A case file should run if it has no successful submission (will retry failed cases)
          echo "Checking for existing submissions..."
          ZIP_COUNT=$(find submissions -name "*.zip" -type f 2>/dev/null | wc -l)
          echo "Found $ZIP_COUNT zip files in submissions/"
          
          # Write case files to temp file and pass as argument to avoid stdin conflicts
          TEMP_CASES=$(mktemp)
          echo "$ALL_CASE_FILES" > "$TEMP_CASES"
          
          PYTHON_OUTPUT=$(python3 - "$TEMP_CASES" << 'PYTHON_SCRIPT'
          import sys
          import yaml
          import zipfile
          from pathlib import Path
          import json
          
          def normalize_yaml_content(content):
              """Normalize YAML content for comparison (remove comments, normalize whitespace)."""
              try:
                  data = yaml.safe_load(content)
                  return yaml.dump(data, sort_keys=True, default_flow_style=False)
              except:
                  return content
          
          def case_has_successful_submission(case_file_path):
              """Check if a case file has at least one successful submission with matching content.
              
              Returns True only if:
              1. A submission exists for this case file (by source_case_file path)
              2. The case.yaml content in the submission matches the current case file
              """
              case_path = Path(case_file_path)
              if not case_path.exists():
                  return False
              
              # Read current case file content
              try:
                  current_case_content = case_path.read_text()
                  current_case_normalized = normalize_yaml_content(current_case_content)
              except Exception as e:
                  print(f"Warning: Failed to read case file {case_file_path}: {e}", file=sys.stderr)
                  return False
              
              # Get relative path from repo root
              try:
                  repo_root = Path.cwd()
                  case_file_rel = str(case_path.resolve().relative_to(repo_root.resolve()))
              except ValueError:
                  case_file_rel = str(case_path.resolve())
              
              case_file_rel_normalized = case_file_rel.replace("\\", "/")
              
              submissions_dir = Path("submissions")
              if not submissions_dir.exists():
                  return False
              
              zip_files = list(submissions_dir.rglob("*.zip"))
              if len(zip_files) == 0:
                  return False  # No submissions exist, so no successful submissions
              
              for zip_path in zip_files:
                  try:
                      with zipfile.ZipFile(zip_path, 'r') as zf:
                          if 'case.yaml' not in zf.namelist() or 'results.json' not in zf.namelist():
                              continue
                          
                          zip_case_content = zf.read('case.yaml').decode('utf-8')
                          zip_case_data = yaml.safe_load(zip_case_content)
                          
                          # Check if this submission is for this case file
                          submission_source = zip_case_data.get('source_case_file', '')
                          if submission_source:
                              submission_source_normalized = submission_source.replace("\\", "/")
                              if (submission_source == case_file_rel or 
                                  submission_source_normalized == case_file_rel_normalized):
                                  # Found a submission for this case file - now check if content matches
                                  zip_case_normalized = normalize_yaml_content(zip_case_content)
                                  if zip_case_normalized == current_case_normalized:
                                      return True  # Content matches, submission is still valid
                                  else:
                                      # Content differs - case file has changed, should rerun
                                      print(f"Case file changed: {case_file_path} (submission from {zip_path.name})", file=sys.stderr)
                                      continue  # Keep looking, but this submission is outdated
                  except Exception as e:
                      print(f"Warning: Failed to process {zip_path}: {e}", file=sys.stderr)
                      continue
              
              return False  # No matching submission found or all submissions have outdated content
          
          # Read case files from file passed as first argument
          if len(sys.argv) > 1:
              with open(sys.argv[1], 'r') as f:
                  case_files = [line.strip() for line in f if line.strip()]
          else:
              case_files = [line.strip() for line in sys.stdin if line.strip()]
          
          if not case_files:
              print("ERROR: No case files found!", file=sys.stderr)
              sys.exit(1)
          
          cases_to_run = []
          cases_already_successful = []
          
          for case_file in case_files:
              if case_has_successful_submission(case_file):
                  cases_already_successful.append(case_file)
                  print(f"SKIP: {case_file} (has successful submission)", file=sys.stderr)
              else:
                  cases_to_run.append(case_file)
                  print(f"RUN: {case_file} (new or no successful submission)", file=sys.stderr)
          
          result = {
              "to_run": cases_to_run,
              "already_successful": cases_already_successful
          }
          print(json.dumps(result))
          PYTHON_SCRIPT
          )
          
          PYTHON_EXIT=$?
          rm -f "$TEMP_CASES"
          
          if [ $PYTHON_EXIT -ne 0 ]; then
            echo "ERROR: Python script failed with exit code $PYTHON_EXIT"
            echo "Output: $PYTHON_OUTPUT"
            exit 1
          fi
          
          if [ -z "$PYTHON_OUTPUT" ]; then
            echo "ERROR: Python script produced no output"
            exit 1
          fi
          
          echo "Python script output: $PYTHON_OUTPUT"
          
          # Extract case files to run from JSON output
          NEW_CASE_FILES=($(echo "$PYTHON_OUTPUT" | python3 -c "import sys, json; data = json.load(sys.stdin); print('\n'.join(data['to_run']))"))
          ALREADY_RUN_CASES=($(echo "$PYTHON_OUTPUT" | python3 -c "import sys, json; data = json.load(sys.stdin); print('\n'.join(data['already_successful']))"))
          
          echo ""
          echo "Summary:"
          echo "  Cases to run (new or failed): ${#NEW_CASE_FILES[@]}"
          echo "  Cases with successful submissions (skipped): ${#ALREADY_RUN_CASES[@]}"
          
          if [ ${#NEW_CASE_FILES[@]} -eq 0 ]; then
            echo ""
            echo "No case files to run. All cases have successful submissions."
            echo "Exiting successfully."
            exit 0
          fi
          
          echo ""
          echo "Case files to run:"
          for case_file in "${NEW_CASE_FILES[@]}"; do
            echo "  - $case_file"
          done
          
          # Run each case (new or previously failed)
          FAILED_CASES=()
          SKIPPED_CASES=()
          for case_file in "${NEW_CASE_FILES[@]}"; do
            echo ""
            echo "=========================================="
            echo "Running case: $case_file"
            echo "(New case or previously failed - will retry until successful)"
            echo "=========================================="
            
            # Check if surface file exists (basic check)
            # Extract surface name from case.yaml
            SURFACE_NAME=$(grep -A 2 "surface_params:" "$case_file" | grep "surface:" | awk '{print $2}' | tr -d '"')
            if [ -n "$SURFACE_NAME" ]; then
              # Check if surface file exists in plasma_surfaces
              if [ ! -f "plasma_surfaces/$SURFACE_NAME" ] && [ ! -f "plasma_surfaces/${SURFACE_NAME,,}" ]; then
                echo "WARNING: Surface file '$SURFACE_NAME' not found in plasma_surfaces/"
                echo "Skipping case: $case_file"
                SKIPPED_CASES+=("$case_file (missing surface: $SURFACE_NAME)")
                continue
              fi
            fi
            
            # Run with error handling
            # Contact and hardware are now auto-detected (no flags needed)
            if ! stellcoilbench submit-case "$case_file"; then
              echo "ERROR: submit-case failed for $case_file!"
              FAILED_CASES+=("$case_file")
            else
              echo "✓ Successfully completed $case_file"
            fi
          done
          
          # Report skipped cases
          if [ ${#SKIPPED_CASES[@]} -gt 0 ]; then
            echo ""
            echo "WARNING: The following cases were skipped:"
            for case in "${SKIPPED_CASES[@]}"; do
              echo "  - $case"
            done
          fi
          
          # Check if any cases failed
          if [ ${#FAILED_CASES[@]} -gt 0 ]; then
            echo ""
            echo "ERROR: The following cases failed:"
            for case in "${FAILED_CASES[@]}"; do
              echo "  - $case"
            done
            echo ""
            echo "Note: Failed cases will be retried on the next CI run until they succeed."
            echo "A case stops being retried once it successfully generates a submission."
            exit 1
          fi
          
          echo ""
          echo "Checking generated submissions..."
          # Submissions are now zipped, so check for zip files
          # Only check if we actually ran cases
          if [ ${#NEW_CASE_FILES[@]} -gt 0 ]; then
            ZIP_COUNT=$(find submissions -name "*.zip" -type f | wc -l)
            echo "Total zip files found: $ZIP_COUNT"
            
            if [ "$ZIP_COUNT" -eq 0 ]; then
              echo "ERROR: No zip files were generated!"
              exit 1
            fi
            
            echo "Submission zip files:"
            find submissions -name "*.zip" -type f | head -20
          else
            echo "No new cases were run, skipping submission check."
          fi

      - name: Configure Git
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "$GITHUB_ACTOR"

      - name: Commit submissions to main
        run: |
          # List what was generated (submissions are now zipped)
          echo "Checking for generated submissions..."
          find submissions -name "*.zip" -type f 2>/dev/null | head -20 || echo "No zip files found"
          
          # Show git status before adding
          echo "Git status before adding:"
          git status --short submissions/ | head -30 || echo "No changes in submissions/"
          
          # Add submission files (including zip files)
          echo "Adding submission files (including zip files)..."
          git add submissions/ || echo "git add failed"
          
          # Explicitly verify zip files are staged
          echo "Checking for staged zip files:"
          git diff --staged --name-only | grep "\.zip$" || echo "No zip files in staged changes"
          
          # Show what's staged
          echo "Staged files:"
          git diff --staged --name-only | head -20 || echo "No staged files"
          
          # Show git status after adding
          echo "Git status after adding:"
          git status --short | head -20
          
          # Commit submissions to main branch
          if ! git diff --staged --quiet; then
            echo "Committing submissions..."
            git commit -m "chore: add CI-generated submission" || (echo "Commit failed" && exit 1)
            echo "Pushing to main..."
            git push origin main || (echo "ERROR: Failed to push to main" && git push origin main --verbose && exit 1)
            echo "Successfully pushed submissions to main"
          else
            echo "INFO: No new submissions to commit"
            echo "This is expected if:"
            echo "  1. No new case files were found to run"
            echo "  2. All cases were skipped (e.g., missing surface files)"
            echo "  3. Files are already committed"
            # Show what git sees
            echo "Files in submissions/:"
            find submissions -type f | head -20
            echo "Git status of submissions/:"
            git status submissions/ || echo "No status"
            echo "Checking for zip files:"
            find submissions -name "*.zip" -type f || echo "No zip files found"
          fi
          
          # Verify submissions still exist after commit
          echo "Submissions after commit:"
          find submissions -name "results.json" -type f | head -10 || echo "No submissions found"

      - name: Generate and commit leaderboard files to main
        run: |
          # Ensure we're on main and have latest submissions
          echo "Current branch: $(git branch --show-current)"
          
          # Step 1 already committed submissions locally and pushed them
          # Fetch the latest to ensure we have Step 1's commits
          echo "Fetching latest from origin (including Step 1's commits)..."
          git fetch origin main || echo "Fetch failed (non-critical)"
          
          # Show what commits we have locally vs remote
          echo "Local commits:"
          git log --oneline -5 || echo "No local commits"
          echo "Remote commits:"
          git log --oneline origin/main -5 || echo "No remote commits"
          
          # Clean up any untracked files in docs/leaderboards/ that would conflict with merge
          # These are generated files that will be regenerated anyway - always remove them
          echo "Cleaning untracked files in docs/leaderboards/ that would conflict with merge..."
          # Aggressively remove all untracked files in docs/leaderboards/
          if [ -d "docs/leaderboards" ]; then
            # Remove all untracked .md files
            find docs/leaderboards -name "*.md" -type f ! -path "*/\.git/*" | while read file; do
              if ! git ls-files --error-unmatch "$file" >/dev/null 2>&1; then
                echo "Removing untracked file: $file"
                rm -f "$file"
              fi
            done
            # Also use git clean as fallback
            git clean -fd docs/leaderboards/ 2>/dev/null || true
          fi
          # Also remove untracked leaderboard.json if it exists
          if [ -f "docs/leaderboard.json" ] && ! git ls-files --error-unmatch docs/leaderboard.json >/dev/null 2>&1; then
            echo "Removing untracked file: docs/leaderboard.json"
            rm -f docs/leaderboard.json
          fi
          
          # Step 1 already committed and pushed submissions locally
          # We need to ensure we have those submissions before generating leaderboards
          # Check if we're ahead of origin/main (Step 1's commits)
          LOCAL_COMMITS=$(git rev-list HEAD ^origin/main 2>/dev/null | wc -l || echo "0")
          echo "Local commits ahead of origin/main: $LOCAL_COMMITS"
          
          # If we have local commits, we already have Step 1's submissions
          # Still fetch to get any other remote updates, but don't merge if it would conflict
          echo "Fetching latest from origin..."
          git fetch origin main || echo "Fetch failed (non-critical)"
          
          # Only merge if we're behind origin/main (to get submissions from previous runs)
          # But preserve local commits from Step 1
          if git rev-parse --verify origin/main > /dev/null 2>&1; then
            BEHIND_COUNT=$(git rev-list origin/main ^HEAD 2>/dev/null | wc -l || echo "0")
            if [ "$BEHIND_COUNT" -gt 0 ]; then
              echo "Merging origin/main to include submissions from previous runs..."
              git merge origin/main --no-edit --no-ff || {
                # If merge fails, resolve conflicts by keeping local submissions
                CONFLICTS=$(git diff --name-only --diff-filter=U 2>/dev/null || true)
                if [ -n "$CONFLICTS" ]; then
                  echo "$CONFLICTS" | grep "^submissions/" | while read file; do
                    [ -n "$file" ] && git checkout --ours "$file" 2>/dev/null && git add "$file" 2>/dev/null || true
                  done
                  echo "$CONFLICTS" | grep "^docs/" | while read file; do
                    [ -n "$file" ] && git checkout --theirs "$file" 2>/dev/null && git add "$file" 2>/dev/null || true
                  done
                  git commit --no-edit || echo "Merge commit failed"
                else
                  git merge --abort 2>/dev/null || true
                fi
              }
            else
              echo "Already up to date with origin/main, using local state"
            fi
          fi
          
          # Count submissions (should include both locally committed and merged from remote)
          # Submissions are now zipped
          SUBMISSIONS_COUNT=$(find submissions -name "*.zip" -type f 2>/dev/null | wc -l)
          echo "Submissions found: $SUBMISSIONS_COUNT"
          echo "All submission zip files:"
          find submissions -name "*.zip" -type f | sort || echo "No zip files found"
          
          # Generate leaderboard files (processes all submissions in submissions/ directory)
          # Remove old leaderboard files first to ensure clean regeneration
          echo "Removing old leaderboard files to ensure clean regeneration..."
          rm -f docs/leaderboard.json
          # Remove all existing leaderboard markdown files
          if [ -d "docs/leaderboards" ]; then
            find docs/leaderboards -name "*.md" -type f -delete
            echo "Removed old leaderboard .md files"
          fi
          
          echo "Generating leaderboard files..."
          stellcoilbench update-db
          
          # Verify all expected leaderboard files were generated
          echo "Verifying generated leaderboard files..."
          if [ -d "docs/leaderboards" ]; then
            echo "Generated leaderboard files:"
            ls -la docs/leaderboards/*.md 2>/dev/null || echo "No .md files found"
            
            # Check for specific surfaces
            for surface in rotating_ellipse LandremanPaul2021_QA circular_tokamak muse_focus; do
              if [ -f "docs/leaderboards/${surface}.md" ]; then
                echo "✓ ${surface}.md exists"
              else
                echo "WARNING: ${surface}.md not found"
              fi
            done
          fi
          
          # Verify files were generated
          echo "Checking generated files..."
          ls -la docs/ 2>/dev/null || echo "docs/ directory not found"
          ls -la docs/*.md 2>/dev/null | head -5 || echo "No markdown files in docs/"
          
          # Add generated leaderboard files
          # Note: docs/leaderboard.json is optional reference, methods.json and cases.json are not saved
          echo "Adding leaderboard files..."
          ADDED_ANY=false
          
          # Add individual files if they exist
          for file in docs/leaderboard.json; do
            if [ -f "$file" ]; then
              echo "Adding $file"
              git add "$file" && ADDED_ANY=true
            else
              echo "File not found: $file"
            fi
          done
          
          # Add leaderboard directories if they exist
          if [ -d "docs/leaderboards" ]; then
            echo "Adding all docs/leaderboards/*.md files"
            # Use find to ensure we get all .md files, including new ones
            find docs/leaderboards -name "*.md" -type f | while read file; do
              echo "  Adding: $file"
              git add "$file" && ADDED_ANY=true
            done
          fi
          
          # Remove old leaderboard file if it exists (singular .md file, replaced by docs/leaderboards/ directory)
          if [ -f "docs/leaderboard.md" ]; then
            echo "Removing old docs/leaderboard.md"
            git rm -f docs/leaderboard.md 2>/dev/null || true
          fi
          # Note: docs/leaderboards/ directory is now tracked, so we don't remove it
          # Files are added/updated explicitly above, and old files will be overwritten by new generation
          
          echo "Files added: $ADDED_ANY"
          
          # Show git status before committing
          echo "Git status before commit:"
          git status --short | head -20
          
          # Commit if there are changes
          if ! git diff --staged --quiet; then
            echo "Committing leaderboard files to main..."
            git commit -m "chore: update StellCoilBench leaderboard" || echo "Commit failed"
            echo "Pushing to main..."
            git push origin main || (echo "ERROR: Failed to push to main" && exit 1)
            echo "Successfully pushed leaderboard files to main"
          else
            echo "No leaderboard changes to commit"
            echo "Staged files:"
            git diff --staged --name-only || echo "No staged files"
            echo "Untracked/modified files:"
            git status --short | grep -E "(docs/|db/)" | head -10 || echo "No leaderboard files found"
          fi

